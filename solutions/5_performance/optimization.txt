# Performance Optimization

## Current Issues
1. Missing code splitting strategy
2. No data caching implementation
3. Large bundle size
4. No image optimization
5. Missing performance monitoring

## Proposed Solutions

### 1. Code Splitting

```typescript
// Route-based code splitting
const Properties = lazy(() => import('./pages/Properties'));
const Tenants = lazy(() => import('./pages/Tenants'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/properties" element={<Properties />} />
        <Route path="/tenants" element={<Tenants />} />
      </Routes>
    </Suspense>
  );
}

// Component-based code splitting
const PropertyModal = lazy(() => 
  import('./components/properties/PropertyModal')
);
```

### 2. Data Caching

```typescript
// src/lib/cache/index.ts
interface CacheConfig {
  ttl: number;
  maxSize: number;
}

class DataCache {
  private cache: Map<string, {
    data: any;
    timestamp: number;
  }>;
  private config: CacheConfig;

  constructor(config: CacheConfig) {
    this.cache = new Map();
    this.config = config;
  }

  set(key: string, data: any) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  get(key: string) {
    const entry = this.cache.get(key);
    if (!entry) return null;

    if (Date.now() - entry.timestamp > this.config.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }
}
```

### 3. Virtual Scrolling

```typescript
// src/components/common/VirtualList.tsx
interface VirtualListProps<T> {
  items: T[];
  renderItem: (item: T) => ReactNode;
  itemHeight: number;
  windowHeight: number;
}

function VirtualList<T>({
  items,
  renderItem,
  itemHeight,
  windowHeight
}: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(windowHeight / itemHeight),
    items.length
  );

  const visibleItems = items.slice(startIndex, endIndex);
  
  return (
    <div
      style={{ height: windowHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight }}>
        <div style={{ transform: `translateY(${startIndex * itemHeight}px)` }}>
          {visibleItems.map(renderItem)}
        </div>
      </div>
    </div>
  );
}
```

### 4. Image Optimization

```typescript
// src/components/common/OptimizedImage.tsx
interface ImageProps {
  src: string;
  alt: string;
  sizes?: string;
  loading?: 'lazy' | 'eager';
}

function OptimizedImage({ src, alt, sizes, loading = 'lazy' }: ImageProps) {
  return (
    <img
      src={src}
      alt={alt}
      loading={loading}
      sizes={sizes}
      srcSet={generateSrcSet(src)}
      className="w-full h-auto"
    />
  );
}

// Image processing utility
function generateSrcSet(src: string): string {
  const sizes = [320, 640, 960, 1280];
  return sizes
    .map(size => `${getOptimizedUrl(src, size)} ${size}w`)
    .join(', ');
}
```

### 5. Performance Monitoring

```typescript
// src/lib/monitoring/performance.ts
export function trackPageLoad() {
  const navigation = performance.getEntriesByType('navigation')[0];
  Sentry.captureMessage('Page Load', {
    extra: {
      loadTime: navigation.duration,
      domInteractive: navigation.domInteractive,
      domComplete: navigation.domComplete
    }
  });
}

export function trackComponentRender(
  component: string,
  duration: number
) {
  if (duration > 16) { // 60fps threshold
    Sentry.captureMessage('Slow Component Render', {
      extra: {
        component,
        duration,
        timestamp: Date.now()
      }
    });
  }
}
```

## Implementation Steps

1. Add Code Splitting
   - Implement route-based splitting
   - Add component-based splitting
   - Configure Suspense boundaries

2. Implement Caching
   - Add cache service
   - Implement cache invalidation
   - Add offline support

3. Add Virtual Scrolling
   - Create VirtualList component
   - Implement scroll position tracking
   - Add item recycling

4. Configure Image Optimization
   - Add image component
   - Configure image processing
   - Implement lazy loading

5. Set Up Monitoring
   - Configure performance tracking
   - Add metrics collection
   - Implement alerts

## Dependencies

- React Router
- Sentry configuration
- Build tools
- Service worker

## Success Criteria

1. Improved load times
2. Reduced bundle size
3. Better scroll performance
4. Optimized images
5. Clear performance metrics
6. Improved offline support