# Authentication Flow Architecture

## Current Issues
1. Unclear separation of concerns between Auth and Firestore
2. Race conditions in user creation flow
3. Inconsistent state management during auth processes
4. Missing proper initialization checks
5. Duplicate Firebase initialization in config.ts
6. Missing error boundaries for auth failures

## Proposed Solution

### 1. Authentication Flow Sequence
```
1. User Signs Up
   ├─> Create Firebase Auth account
   ├─> Generate initial auth token
   ├─> Create Firestore user document
   └─> Initialize Redux state

2. User Signs In
   ├─> Authenticate with Firebase
   ├─> Fetch user document
   ├─> Update Redux state
   └─> Initialize application state

3. Session Management
   ├─> Listen to Auth state changes
   ├─> Sync with Firestore document
   └─> Update Redux store
```

### 2. Clear Boundaries

```typescript
// 1. Authentication Layer (Firebase Auth)
- User credentials
- Token management
- Session state

// 2. Data Layer (Firestore)
- User profile data
- Role management
- Application state

// 3. Application Layer (Redux)
- UI state
- Cached data
- Current session info

// 4. Error Boundaries
- Auth errors
- Network errors
- Validation errors
```

### 3. Initialization Flow
```
1. Application Starts
   ├─> Check for existing auth session
   ├─> Initialize Firebase Auth listener
   ├─> Initialize error boundaries
   ├─> Sync with Firestore
   └─> Update Redux store

2. Auth State Changes
   ├─> Update token
   ├─> Fetch latest user data
   └─> Update application state
```

## Implementation Steps

1. Create AuthProvider
```typescript
// src/providers/AuthProvider.tsx
const AuthProvider: FC = ({ children }) => {
  const dispatch = useDispatch();
  const [isInitialized, setIsInitialized] = useState(false);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, handleAuthStateChange);
    return () => unsubscribe();
  }, [dispatch]);

  if (!isInitialized) {
    return <LoadingSpinner />;
  }

  return <>{children}</>;
};
```

2. Fix Firebase Config
```typescript
// src/lib/firebase/config.ts
let app: FirebaseApp;

export function initializeFirebase() {
  if (!app) {
    app = initializeApp(firebaseConfig);
  }
  return app;
}

export function getFirebaseAuth() {
  const app = initializeFirebase();
  return getAuth(app);
}

export function getFirestore() {
  const app = initializeFirebase();
  return initializeFirestore(app);
}
```

3. Add Error Boundary
```typescript
// src/components/auth/AuthErrorBoundary.tsx
class AuthErrorBoundary extends React.Component<Props, State> {
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: ErrorInfo) {
    captureError(error, {
      component: 'AuthErrorBoundary',
      ...info
    });
  }

  render() {
    if (this.state.hasError) {
      return <AuthErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}
```

4. Update App Component
```typescript
// src/App.tsx
function App() {
  return (
    <Provider store={store}>
      <AuthErrorBoundary>
        <AuthProvider>
          <Router>
            <Routes>
              {/* ... routes ... */}
            </Routes>
          </Router>
        </AuthProvider>
      </AuthErrorBoundary>
    </Provider>
  );
}
```

5. Handle Auth State Changes
```typescript
// src/providers/AuthProvider.tsx
const handleAuthStateChange = async (firebaseUser: User | null) => {
  setIsInitialized(false);
  
  if (!firebaseUser) {
    dispatch(setAuthState({ status: 'unauthenticated' }));
    setIsInitialized(true);
    return;
  }

  try {
    const userDoc = await fetchUserDocument(firebaseUser.uid);
    if (!userDoc) {
      throw new Error('User document not found');
    }

    dispatch(setAuthState({
      status: 'authenticated',
      user: {
        id: firebaseUser.uid,
        email: firebaseUser.email || '',
        ...userDoc
      }
    }));
  } catch (error) {
    dispatch(setAuthState({ 
      status: 'error',
      error: error instanceof Error ? error : new Error('Authentication failed')
    }));
  } finally {
    setIsInitialized(true);
  }
};
```

## Dependencies

- Firebase Auth configuration
- Firestore security rules
- Redux store structure
- Error tracking setup

## Success Criteria

1. Clear separation between auth and data layers
2. No race conditions during user creation
3. Consistent state management
4. Proper error handling
5. Clear loading states
6. No duplicate Firebase initialization
7. Proper error boundaries for auth failures
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, handleAuthStateChange);
    return () => unsubscribe();
  }, []);

  return <>{children}</>;
};
```

2. Define Clear Auth States
```typescript
type AuthState = 
  | { status: 'initializing' }
  | { status: 'authenticated'; user: User }
  | { status: 'unauthenticated' }
  | { status: 'error'; error: Error };
```

3. Handle Auth State Changes
```typescript
const handleAuthStateChange = async (firebaseUser: User | null) => {
  if (!firebaseUser) {
    dispatch(setAuthState({ status: 'unauthenticated' }));
    return;
  }

  try {
    const userDoc = await fetchUserDocument(firebaseUser.uid);
    dispatch(setAuthState({
      status: 'authenticated',
      user: { ...firebaseUser, ...userDoc }
    }));
  } catch (error) {
    dispatch(setAuthState({ status: 'error', error }));
  }
};
```

## Next Steps

1. Implement AuthProvider
2. Update security rules to match new flow
3. Modify Redux store to handle new auth states
4. Update UI components to handle all possible states

## Dependencies

- Firebase Auth configuration
- Firestore security rules
- Redux store structure

## Success Criteria

1. Clear separation between auth and data layers
2. No race conditions during user creation
3. Consistent state management
4. Proper error handling
5. Clear loading states